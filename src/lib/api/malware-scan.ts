/**
 * Malware scanning using VirusTotal API
 *
 * VirusTotal free tier: 500 requests/day, 4 requests/minute
 * Uses hash lookup first (efficient), then upload if unknown.
 *
 * Random sampling is used to conserve API quota:
 * - PDFs: 100% scanned (higher risk)
 * - TXT/MD: 20% scanned (lower risk, plain text)
 *
 * Gracefully falls back to allowing uploads when:
 * - API key not configured
 * - Rate limited (429)
 * - Quota exhausted
 * - Network errors
 */

import { createHash } from 'crypto';

export interface ScanResult {
  scanned: boolean;
  clean: boolean;
  threat?: string;
  error?: string;
  skippedReason?: 'no_api_key' | 'rate_limited' | 'sampling' | 'network_error' | 'quota_exhausted';
}

// Sampling rates by file type
const SCAN_RATES: Record<string, number> = {
  pdf: 0.75,  // 75% - higher risk
  txt: 0.2,   // 20% - lower risk
  md: 0.2,    // 20% - lower risk
};

// Track rate limit state (reset after cooldown)
let rateLimitedUntil = 0;
let quotaExhaustedUntil = 0;

const RATE_LIMIT_COOLDOWN_MS = 60_000;      // 1 minute cooldown after 429
const QUOTA_EXHAUSTED_COOLDOWN_MS = 3600_000; // 1 hour cooldown after quota error

/**
 * Calculate SHA256 hash of a buffer
 */
function calculateHash(buffer: Buffer): string {
  return createHash('sha256').update(buffer).digest('hex');
}

/**
 * Check if we should scan this file based on sampling rate
 */
function shouldSample(fileType: string): boolean {
  const rate = SCAN_RATES[fileType.toLowerCase()] ?? 0.5; // Default 50%
  return Math.random() < rate;
}

/**
 * Check if we're currently rate limited or quota exhausted
 */
function isThrottled(): { throttled: boolean; reason?: 'rate_limited' | 'quota_exhausted' } {
  const now = Date.now();

  if (quotaExhaustedUntil > now) {
    return { throttled: true, reason: 'quota_exhausted' };
  }

  if (rateLimitedUntil > now) {
    return { throttled: true, reason: 'rate_limited' };
  }

  return { throttled: false };
}

/**
 * Look up file hash in VirusTotal database
 * This is fast and uses 1 API call
 */
async function lookupHash(
  apiKey: string,
  hash: string
): Promise<{ found: boolean; malicious: boolean; threat?: string; rateLimited?: boolean; quotaExhausted?: boolean }> {
  try {
    const response = await fetch(`https://www.virustotal.com/api/v3/files/${hash}`, {
      method: 'GET',
      headers: {
        'x-apikey': apiKey,
      },
    });

    if (response.status === 429) {
      rateLimitedUntil = Date.now() + RATE_LIMIT_COOLDOWN_MS;
      console.warn('VirusTotal rate limited, cooling down for 1 minute');
      return { found: false, malicious: false, rateLimited: true };
    }

    if (response.status === 401) {
      console.error('VirusTotal API key invalid');
      return { found: false, malicious: false };
    }

    if (response.status === 404) {
      // File not in database - not necessarily clean, just unknown
      return { found: false, malicious: false };
    }

    if (!response.ok) {
      // Check for quota exhaustion
      const text = await response.text();
      if (text.includes('QuotaExceeded')) {
        quotaExhaustedUntil = Date.now() + QUOTA_EXHAUSTED_COOLDOWN_MS;
        console.warn('VirusTotal quota exhausted, cooling down for 1 hour');
        return { found: false, malicious: false, quotaExhausted: true };
      }
      console.error(`VirusTotal lookup error: ${response.status}`);
      return { found: false, malicious: false };
    }

    const data = await response.json();
    const stats = data.data?.attributes?.last_analysis_stats;

    if (!stats) {
      return { found: true, malicious: false };
    }

    // Check if any engines flagged it as malicious
    const maliciousCount = stats.malicious || 0;
    const suspiciousCount = stats.suspicious || 0;

    if (maliciousCount > 0 || suspiciousCount > 2) {
      // Get threat name from results
      const results = data.data?.attributes?.last_analysis_results || {};
      const threats = Object.values(results)
        .filter((r: unknown) => {
          const result = r as { category?: string; result?: string };
          return result.category === 'malicious' && result.result;
        })
        .map((r: unknown) => (r as { result: string }).result)
        .slice(0, 3);

      return {
        found: true,
        malicious: true,
        threat: threats.join(', ') || 'Potential threat detected',
      };
    }

    return { found: true, malicious: false };
  } catch (error) {
    console.error('VirusTotal lookup error:', error);
    return { found: false, malicious: false };
  }
}

/**
 * Upload file to VirusTotal for scanning (for unknown files)
 * This is slower and uses 1 API call
 */
async function uploadForScan(
  apiKey: string,
  buffer: Buffer,
  filename: string
): Promise<{ scanned: boolean; malicious: boolean; threat?: string; rateLimited?: boolean; quotaExhausted?: boolean }> {
  try {
    // Create form data - convert Buffer to Uint8Array for Blob compatibility
    const formData = new FormData();
    formData.append('file', new Blob([new Uint8Array(buffer)]), filename);

    const response = await fetch('https://www.virustotal.com/api/v3/files', {
      method: 'POST',
      headers: {
        'x-apikey': apiKey,
      },
      body: formData,
    });

    if (response.status === 429) {
      rateLimitedUntil = Date.now() + RATE_LIMIT_COOLDOWN_MS;
      console.warn('VirusTotal rate limited on upload');
      return { scanned: false, malicious: false, rateLimited: true };
    }

    if (!response.ok) {
      const text = await response.text();
      if (text.includes('QuotaExceeded')) {
        quotaExhaustedUntil = Date.now() + QUOTA_EXHAUSTED_COOLDOWN_MS;
        console.warn('VirusTotal quota exhausted on upload');
        return { scanned: false, malicious: false, quotaExhausted: true };
      }
      console.error(`VirusTotal upload error: ${response.status}`);
      return { scanned: false, malicious: false };
    }

    // File uploaded - VirusTotal will scan it asynchronously
    // For immediate response, we'll consider it clean (scan results come later)
    // In a production system, you might want to poll for results or use webhooks
    console.log(`File ${filename} submitted to VirusTotal for scanning`);

    return { scanned: true, malicious: false };
  } catch (error) {
    console.error('VirusTotal upload error:', error);
    return { scanned: false, malicious: false };
  }
}

/**
 * Scan a file buffer for malware using VirusTotal
 *
 * @param buffer - File buffer to scan
 * @param filename - Original filename (for logging)
 * @param fileType - File type (pdf, txt, md) for sampling decision
 * @returns Scan result with clean status
 */
export async function scanForMalware(
  buffer: Buffer,
  filename: string,
  fileType: string = 'unknown'
): Promise<ScanResult> {
  const apiKey = process.env.VIRUSTOTAL_API_KEY;

  // Check if API key is configured
  if (!apiKey) {
    return {
      scanned: false,
      clean: true,
      skippedReason: 'no_api_key',
    };
  }

  // Check if we're throttled
  const throttleStatus = isThrottled();
  if (throttleStatus.throttled) {
    return {
      scanned: false,
      clean: true, // Fail open
      skippedReason: throttleStatus.reason,
    };
  }

  // Check sampling - skip some files to conserve quota
  if (!shouldSample(fileType)) {
    return {
      scanned: false,
      clean: true,
      skippedReason: 'sampling',
    };
  }

  // Calculate file hash
  const hash = calculateHash(buffer);

  // Try hash lookup first (fast, efficient)
  const lookupResult = await lookupHash(apiKey, hash);

  if (lookupResult.rateLimited) {
    return {
      scanned: false,
      clean: true,
      skippedReason: 'rate_limited',
    };
  }

  if (lookupResult.quotaExhausted) {
    return {
      scanned: false,
      clean: true,
      skippedReason: 'quota_exhausted',
    };
  }

  if (lookupResult.found) {
    if (lookupResult.malicious) {
      console.warn(`Malware detected in ${filename}: ${lookupResult.threat}`);
      return {
        scanned: true,
        clean: false,
        threat: lookupResult.threat,
      };
    }
    // Known file, clean
    return {
      scanned: true,
      clean: true,
    };
  }

  // File not in database - upload for scanning (optional, uses more quota)
  // For free tier conservation, we skip upload and just check hash
  // Uncomment below to enable full upload scanning:
  /*
  const uploadResult = await uploadForScan(apiKey, buffer, filename);
  if (uploadResult.rateLimited || uploadResult.quotaExhausted) {
    return {
      scanned: false,
      clean: true,
      skippedReason: uploadResult.rateLimited ? 'rate_limited' : 'quota_exhausted',
    };
  }
  return {
    scanned: uploadResult.scanned,
    clean: !uploadResult.malicious,
    threat: uploadResult.threat,
  };
  */

  // Hash not found - file is unknown to VirusTotal
  // This doesn't mean it's clean, but we allow it (fail open)
  return {
    scanned: true,
    clean: true,
  };
}

/**
 * Check if malware scanning is available
 */
export async function isScanningAvailable(): Promise<boolean> {
  return !!process.env.VIRUSTOTAL_API_KEY;
}
